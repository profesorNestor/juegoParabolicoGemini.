<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parabolic Strike Challenge</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent bouncing on mobile */
        }
        body {
            font-family: 'Inter', sans-serif;
            background: #3e2723;
        }
        .game-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background-color: #f0f9ff;
        }
        canvas {
            background-color: #d4f1f9; /* Light blue sky color */
            cursor: grab;
            border-bottom: 5px solid #4CAF50;
            flex-grow: 1; /* Allow canvas to take available space */
            touch-action: none; /* Prevent default touch actions like scrolling */
        }
        canvas:active {
            cursor: grabbing;
        }
        .stats-bar {
            font-family: 'Bangers', cursive;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 10px 20px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            text-shadow: 2px 2px 4px #000000;
            font-size: 1.2rem;
            letter-spacing: 2px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .stat {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .controls-bar {
            background-color: #3e2723;
            padding: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            border-top: 5px solid #5d4037;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            font-weight: 600;
        }
        .control-group label, .control-group select {
            margin-bottom: 5px;
            font-size: 1rem;
        }
        .control-group select {
            color: #333;
            border-radius: 5px;
            padding: 5px;
        }
        input[type="range"] {
            -webkit-appearance: none;
            width: 150px; /* Smaller for mobile */
            height: 15px;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            border-radius: 10px;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            background: #4CAF50;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
        }
        .game-button {
            font-family: 'Bangers', cursive;
            background-color: #ff9800;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 1.2rem;
            letter-spacing: 1px;
            box-shadow: 0 4px #c66900;
            text-shadow: 1px 1px 2px #000000;
        }
        .game-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px #c66900;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background: #fff;
            padding: 20px;
            border-radius: 20px;
            text-align: center;
            width: 90%;
            max-width: 500px;
            position: relative;
            border: 10px solid #4CAF50;
        }
        .modal-content h2 {
            font-family: 'Bangers', cursive;
            font-size: 2.2rem;
            color: #4CAF50;
            margin-bottom: 20px;
        }
        .option-button {
            display: block; width: 100%; padding: 15px; margin: 10px 0; font-size: 1.2rem;
            cursor: pointer; border-radius: 10px; border: 2px solid #ccc; background-color: #f9f9f9;
            transition: all 0.2s ease;
        }
        .option-button:hover { background-color: #e0e0e0; border-color: #999; }
        #feedbackModal .modal-content, #hintModal .modal-content, #levelUpModal .modal-content, #helpModal .modal-content {
            border-color: #ff9800;
        }
        #feedbackModal h2, #hintModal h2, #levelUpModal h2, #helpModal h2 { color: #ff9800; }
        #targetInfoModal .modal-content { max-width: 300px; border-color: #2196F3; padding: 20px; }
        #targetInfoModal h2 { color: #2196F3; font-size: 2rem; }
    </style>
</head>
<body>

    <div class="game-container">
        <!-- Statistics Bar -->
        <div class="stats-bar">
            <div class="stat">Nivel: <span id="level">1</span></div>
            <div class="stat">‚ù§Ô∏è Vidas: <span id="lives">10</span></div>
            <div class="stat">üéØ Puntos: <span id="score">0</span></div>
            <div class="stat">‚úîÔ∏è Progreso: <span id="progress">0/5</span></div>
            <div class="stat">‚≠ê Nota: <span id="grade">0.0</span></div>
        </div>

        <!-- Game Canvas -->
        <canvas id="gameCanvas"></canvas>

        <!-- Controls Bar -->
        <div class="controls-bar">
            <div class="control-group">
                <label for="velocity">Velocidad: <span id="velocityValue">50</span></label>
                <input type="range" id="velocity" min="10" max="100" value="50">
            </div>
            <div class="control-group">
                <label for="angle">√Ångulo: <span id="angleValue">45</span>¬∞</label>
                <input type="range" id="angle" min="10" max="80" value="45">
            </div>
             <div class="control-group">
                <label for="levelSelect">Elegir Nivel</label>
                <select id="levelSelect">
                    <option value="1">Nivel 1</option>
                    <option value="2">Nivel 2</option>
                    <option value="3">Nivel 3</option>
                </select>
            </div>
            <button id="fireButton" class="game-button">¬°Fuego!</button>
            <button id="pauseButton" class="game-button">Pausa</button>
            <button id="helpButton" class="game-button">Ayuda</button>
            <button id="resetButton" class="game-button">Reiniciar</button>
        </div>
    </div>

    <!-- Modals -->
    <div id="questionModal" class="modal"><div class="modal-content"><h2 id="questionTitle">¬°Pregunta de F√≠sica!</h2><p id="questionText" class="text-lg mb-4"></p><div id="optionsContainer"></div></div></div>
    <div id="feedbackModal" class="modal"><div class="modal-content"><h2 id="feedbackTitle"></h2><p id="feedbackText" class="text-lg mb-4"></p><button id="nextButton" class="game-button">Continuar</button></div></div>
    <div id="targetInfoModal" class="modal"><div class="modal-content"><h2>Coordenadas del Blanco</h2><p id="targetCoordsText" class="text-lg mb-4"></p><button id="closeTargetInfo" class="game-button" style="background-color: #2196F3;">Cerrar</button></div></div>
    <div id="hintModal" class="modal"><div class="modal-content"><h2>üíé ¬°Pista de F√≠sica! üíé</h2><p id="hintText" class="text-lg mb-4"></p><button id="closeHint" class="game-button">¬°Entendido!</button></div></div>
    <div id="levelUpModal" class="modal"><div class="modal-content"><h2 id="levelUpTitle"></h2><p id="levelUpText" class="text-lg mb-4"></p><button id="nextLevelButton" class="game-button">¬°Siguiente Nivel!</button></div></div>
    <div id="helpModal" class="modal"><div class="modal-content"><h2>C√≥mo Jugar</h2><div style="text-align: left; margin-bottom: 1rem; font-size: 0.9rem;"><p><strong>Objetivo:</strong> Golpea el blanco con el proyectil y responde correctamente la pregunta de f√≠sica para avanzar de nivel.</p><br><p><strong>Controles:</strong><br>‚Ä¢ Usa los deslizadores para ajustar la <strong>Velocidad</strong> y el <strong>√Ångulo</strong>.<br>‚Ä¢ Presiona <strong>¬°Fuego!</strong> para disparar.<br>‚Ä¢ <strong>Arrastre/Panning (PC):</strong> Mant√©n presionado el bot√≥n del rat√≥n y arrastra para mover la vista.<br>‚Ä¢ <strong>Arrastre/Panning (M√≥vil):</strong> Desliza un dedo por la pantalla para mover la vista.</p><br><p><strong>Puntuaci√≥n:</strong><br>‚Ä¢ Acierto al blanco: +100 puntos.<br>‚Ä¢ Respuesta correcta: +50 puntos.<br>‚Ä¢ Fallar el tiro: -25 puntos.<br>‚Ä¢ Golpear una üí£: -50 puntos y pierdes una vida.<br>‚Ä¢ Golpear una üíé: ¬°Obtienes una pista de f√≠sica!</p></div><button id="closeHelp" class="game-button">¬°Entendido!</button></div></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game State
        let lives = 10, score = 0, isPaused = false, gameOver = false;
        
        // Level State
        let currentLevel = 1;
        const levelConfig = { 1: { questions: 5 }, 2: { questions: 10 }, 3: { questions: 30 } };
        let correctAnswersThisLevel = 0, totalQuestionsAnswered = 0, totalCorrectAnswers = 0;
        let questionTypesAvailable = [];

        // Physics variables
        let velocity = 50, angle = 45, g = 9.81;

        // Game objects
        let projectile = null, target = {}, cannon = {}, fallingObjects = [];
        
        // Panning and interaction
        let panOffsetX = 0, panOffsetY = 0, isPanning = false;
        let panStart = { x: 0, y: 0 }, hasPanned = false;

        // UI Elements
        const levelSpan = document.getElementById('level'), livesSpan = document.getElementById('lives'),
              scoreSpan = document.getElementById('score'), progressSpan = document.getElementById('progress'),
              gradeSpan = document.getElementById('grade'), velocitySlider = document.getElementById('velocity'),
              velocityValueSpan = document.getElementById('velocityValue'), angleSlider = document.getElementById('angle'),
              angleValueSpan = document.getElementById('angleValue'), levelSelect = document.getElementById('levelSelect'),
              fireButton = document.getElementById('fireButton'), pauseButton = document.getElementById('pauseButton'),
              resetButton = document.getElementById('resetButton'), helpButton = document.getElementById('helpButton'),
              modals = { question: document.getElementById('questionModal'), feedback: document.getElementById('feedbackModal'),
                         targetInfo: document.getElementById('targetInfoModal'), hint: document.getElementById('hintModal'),
                         levelUp: document.getElementById('levelUpModal'), help: document.getElementById('helpModal') };

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = document.querySelector('.game-container').clientHeight - document.querySelector('.stats-bar').offsetHeight - document.querySelector('.controls-bar').offsetHeight;
        }
        
        function setupLevel(level, resetAll = false) {
            currentLevel = level;
            levelSelect.value = level;
            correctAnswersThisLevel = 0;
            totalQuestionsAnswered = 0;
            if (resetAll) {
                score = 0;
                lives = 10;
                totalCorrectAnswers = 0;
            }
            fillQuestionTypes();
            updateStats();
        }

        function setupGame() {
            resizeCanvas();
            isPaused = false; gameOver = false; projectile = null;
            fallingObjects = []; panOffsetX = 0; panOffsetY = 0;
            cannon = { x: 50, y: canvas.height - 50 };
            const startingLevel = parseInt(levelSelect.value, 10);
            setupLevel(startingLevel, true);
            placeNewTarget();
            if(window.gameLoopId) cancelAnimationFrame(window.gameLoopId);
            gameLoop();
        }
        
        function fillQuestionTypes() {
             questionTypesAvailable = ['maxHeight', 'range', 'totalTime', 'timeToPeak', 'vx_at_t', 'vy_at_t'];
        }

        function placeNewTarget() {
            const origin = { x: 50, y: canvas.height - 20 };
            target = {
                x: origin.x + 150 + Math.random() * (canvas.width * 1.5), // Allow off-screen targets
                y: origin.y - 100 - Math.random() * (origin.y - 150),
                radius: 20 + Math.random() * 20
            };
        }

        function updateStats() {
            levelSpan.textContent = currentLevel;
            livesSpan.textContent = lives;
            scoreSpan.textContent = score;
            const requiredQuestions = levelConfig[currentLevel].questions;
            progressSpan.textContent = `${correctAnswersThisLevel}/${requiredQuestions}`;
            let grade = (totalQuestionsAnswered === 0) ? 0 : (totalCorrectAnswers / totalQuestionsAnswered) * 5;
            gradeSpan.textContent = isNaN(grade) ? '0.0' : grade.toFixed(1);
            if (lives <= 0) {
                gameOver = true;
                showFeedback("¬°Juego Terminado!", `Te quedaste sin vidas. Tu puntaje final es ${score}.`);
            }
        }

        function fireProjectile() {
            if (projectile || isPaused) return;
            const angleRad = angle * Math.PI / 180;
            const pixelsPerMeter = 3;
            projectile = {
                x: cannon.x, y: cannon.y,
                vx: velocity * Math.cos(angleRad) * pixelsPerMeter,
                vy: -velocity * Math.sin(angleRad) * pixelsPerMeter,
                radius: 10, path: [{x: cannon.x, y: cannon.y}]
            };
        }

        function update(dt) {
            if (!projectile) return;
            const pixelsPerMeter = 3;
            projectile.vy += g * dt * pixelsPerMeter;
            projectile.x += projectile.vx * dt;
            projectile.y += projectile.vy * dt;
            projectile.path.push({x: projectile.x, y: projectile.y});
            if(projectile.path.length > 200) projectile.path.shift();

            const worldProjectileX = projectile.x + panOffsetX;
            const worldProjectileY = projectile.y + panOffsetY;
            const dx = worldProjectileX - target.x;
            const dy = worldProjectileY - target.y;

            if (Math.sqrt(dx * dx + dy * dy) < projectile.radius + target.radius) {
                score += 100;
                projectile = null;
                showQuestion();
                return;
            }

            if (worldProjectileY > canvas.height - 20 || worldProjectileX > canvas.width || worldProjectileX < 0) {
                projectile = null;
                lives--;
                score = Math.max(0, score - 25);
                updateStats();
            }
        }
        
        function updateFallingObjects(dt) {
            if(Math.random() < 0.015 && !isPaused) {
                fallingObjects.push({ x: Math.random() * (canvas.width + 400) - panOffsetX, y: -20 - panOffsetY, type: Math.random() < 0.3 ? 'bomb' : 'gem', speed: 2 + Math.random() * 3});
            }
            for(let i = fallingObjects.length - 1; i >= 0; i--) {
                let obj = fallingObjects[i];
                obj.y += obj.speed;
                if(projectile) {
                     const dx = (projectile.x + panOffsetX) - (obj.x + panOffsetX); 
                     const dy = (projectile.y + panOffsetY) - (obj.y + panOffsetY);
                     if (Math.sqrt(dx * dx + dy * dy) < projectile.radius + 20) {
                        if (obj.type === 'gem') showHint();
                        else { lives--; score = Math.max(0, score - 50); updateStats(); }
                        fallingObjects.splice(i, 1);
                     }
                }
                if((obj.y + panOffsetY) > canvas.height + 20) fallingObjects.splice(i, 1);
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(panOffsetX, panOffsetY);
            drawGridAndAxes();
            ctx.fillStyle = '#4CAF50'; ctx.fillRect(-panOffsetX, canvas.height - 20 - panOffsetY, canvas.width, 20);
            
            ctx.save(); ctx.translate(cannon.x, cannon.y); ctx.rotate(-angle * Math.PI / 180);
            ctx.fillStyle = "#37474F"; ctx.fillRect(0, -15, 80, 30);
            ctx.beginPath(); ctx.arc(0, 0, 25, 0, Math.PI * 2); ctx.fill(); ctx.restore();

            ctx.beginPath(); ctx.arc(target.x - panOffsetX, target.y - panOffsetY, target.radius, 0, 2 * Math.PI); ctx.fillStyle = 'red'; ctx.fill();
            ctx.beginPath(); ctx.arc(target.x - panOffsetX, target.y - panOffsetY, target.radius * 0.6, 0, 2 * Math.PI); ctx.fillStyle = 'white'; ctx.fill();
            ctx.beginPath(); ctx.arc(target.x - panOffsetX, target.y - panOffsetY, target.radius * 0.2, 0, 2 * Math.PI); ctx.fillStyle = 'red'; ctx.fill();

            if (projectile) {
                ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth = 3; ctx.beginPath();
                if(projectile.path.length > 0) {
                    ctx.moveTo(projectile.path[0].x, projectile.path[0].y);
                    for(let i = 1; i < projectile.path.length; i++) ctx.lineTo(projectile.path[i].x, projectile.path[i].y);
                }
                ctx.stroke();
                ctx.beginPath(); ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2); ctx.fillStyle = 'black'; ctx.fill();
            }
            
            ctx.font = '30px serif';
            for(const obj of fallingObjects) ctx.fillText(obj.type === 'bomb' ? 'üí£' : 'üíé', obj.x, obj.y);
            ctx.restore();
        }
        
        function drawGridAndAxes() {
            const originX = 50, originY = canvas.height - 20; const pixelsPerMeter = 3; const gridSpacing = 20;
            ctx.save();
            ctx.strokeStyle = "rgba(0, 0, 0, 0.2)"; ctx.fillStyle = "#333"; ctx.font = "12px Inter"; ctx.lineWidth = 0.5;
            for (let i = 1; (originX + i * gridSpacing * pixelsPerMeter) < canvas.width - panOffsetX; i++) {
                const xPos = originX + i * gridSpacing * pixelsPerMeter;
                ctx.beginPath(); ctx.moveTo(xPos, -panOffsetY); ctx.lineTo(xPos, originY); ctx.stroke();
                ctx.textAlign = "center"; ctx.fillText(`${i * gridSpacing}m`, xPos, originY + 15);
            }
            for (let i = 1; (i * gridSpacing * pixelsPerMeter) < canvas.height - panOffsetY; i++) {
                const yPos = originY - i * gridSpacing * pixelsPerMeter;
                ctx.beginPath(); ctx.moveTo(-panOffsetX, yPos); ctx.lineTo(canvas.width - panOffsetX, yPos); ctx.stroke();
                ctx.textAlign = "right"; ctx.textBaseline = "middle"; ctx.fillText(`${i * gridSpacing}m`, originX - 8, yPos);
            }
            ctx.strokeStyle = "#000"; ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(originX, -panOffsetY); ctx.lineTo(originX, originY); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(-panOffsetX, originY); ctx.lineTo(canvas.width - panOffsetX, originY); ctx.stroke();
            ctx.fillText("0", originX - 10, originY + 15);
            ctx.restore();
        }

        let lastTime = 0;
        function gameLoop(timestamp) {
            window.gameLoopId = requestAnimationFrame(gameLoop);
            if(isPaused || gameOver) return;
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            if (dt > 0.1) return;
            update(dt || 0); updateFallingObjects(dt || 0); draw();
        }
        
        function showHint() {
            isPaused = true;
            const hints = ["El √°ngulo de 45¬∞ da el mayor alcance horizontal.", "La velocidad horizontal (Vx) es constante.", "En la altura m√°xima, la velocidad vertical (Vy) es cero.", "√Ångulos complementarios (ej. 30¬∞ y 60¬∞) dan el mismo alcance.", "La gravedad solo afecta el movimiento vertical."];
            modals.hint.querySelector('#hintText').textContent = hints[Math.floor(Math.random() * hints.length)];
            modals.hint.style.display = 'flex';
        }

        function showQuestion() { /* ... full implementation in next block ... */ }
        function checkAnswer(selected, correct) { /* ... full implementation in next block ... */ }
        function showLevelUpModal(nextLevel) { /* ... full implementation in next block ... */ }
        function goToNextLevel() { /* ... full implementation in next block ... */ }
        function showFeedback(title, text) { /* ... full implementation in next block ... */ }
        function hideAndResume() { /* ... full implementation in next block ... */ }
        function handleInteractionStart(e) { /* ... full implementation in next block ... */ }
        function handleInteractionMove(e) { /* ... full implementation in next block ... */ }
        function handleInteractionEnd(e) { /* ... full implementation in next block ... */ }
        
        // Refactored functions for brevity in this view
        const getInteractionCoords = (e) => e.touches ? { x: e.touches[0].clientX, y: e.touches[0].clientY } : { x: e.clientX, y: e.clientY };
        showQuestion = () => {
            isPaused = true;
            const angleRad = angle * Math.PI / 180, v0x = velocity * Math.cos(angleRad), v0y = velocity * Math.sin(angleRad),
                  timeToPeak = v0y / g, maxHeight = (v0y * v0y) / (2 * g), totalTime = 2 * timeToPeak, range = v0x * totalTime,
                  t_rand = Math.random() * totalTime;
            if (questionTypesAvailable.length === 0) fillQuestionTypes();
            const qType = questionTypesAvailable.splice(Math.floor(Math.random() * questionTypesAvailable.length), 1)[0];
            let qData;
            switch(qType) {
                case 'maxHeight': qData = {q: `¬øCu√°l es la altura m√°xima (Ymax) alcanzada?`, correct: maxHeight, unit: "m"}; break;
                case 'range': qData = {q: `¬øCu√°l es el alcance horizontal (Xmax)?`, correct: range, unit: "m"}; break;
                case 'totalTime': qData = {q: `¬øCu√°nto tiempo total permanece el proyectil en el aire?`, correct: totalTime, unit: "s"}; break;
                case 'timeToPeak': qData = {q: `¬øEn qu√© tiempo el proyectil alcanza su altura m√°xima?`, correct: timeToPeak, unit: "s"}; break;
                case 'vx_at_t': qData = {q: `¬øCu√°l es la velocidad horizontal (Vx) en t=${t_rand.toFixed(1)}s?`, correct: v0x, unit: "m/s"}; break;
                case 'vy_at_t': qData = {q: `¬øCu√°l es la velocidad vertical (Vy) en t=${t_rand.toFixed(1)}s?`, correct: v0y - g * t_rand, unit: "m/s"}; break;
                default: fillQuestionTypes(); showQuestion(); return;
            }
            modals.question.querySelector('#questionText').textContent = qData.q;
            const optionsContainer = modals.question.querySelector('#optionsContainer');
            optionsContainer.innerHTML = ''; let options = [qData.correct];
            while (options.length < 4) {
                const wrongOption = qData.correct * (0.5 + Math.random() * 1.2);
                if (options.every(opt => Math.abs(opt - wrongOption) > 0.01)) options.push(wrongOption);
            }
            options.sort(() => Math.random() - 0.5).forEach(option => {
                const btn = document.createElement('button');
                btn.className = 'option-button';
                btn.textContent = `${option.toFixed(2)} ${qData.unit}`;
                btn.onclick = () => checkAnswer(option, qData.correct);
                optionsContainer.appendChild(btn);
            });
            modals.question.style.display = 'flex';
        };
        checkAnswer = (selected, correct) => {
            modals.question.style.display = 'none';
            totalQuestionsAnswered++;
            const isCorrect = Math.abs(selected - correct) < 0.01;
            if (isCorrect) {
                score += 50; correctAnswersThisLevel++; totalCorrectAnswers++;
                if (correctAnswersThisLevel >= levelConfig[currentLevel].questions) {
                     if (levelConfig[currentLevel + 1]) showLevelUpModal(currentLevel + 1);
                     else { gameOver = true; showFeedback("¬°FELICIDADES!", "¬°Has completado todos los niveles y ganado el juego!"); }
                } else { showFeedback("¬°Correcto!", "¬°Excelente! Nuevo blanco en posici√≥n."); placeNewTarget(); }
            } else { lives--; showFeedback("Incorrecto", `La respuesta correcta era ${correct.toFixed(2)}. ¬°Intenta golpear el mismo blanco de nuevo!`); }
            updateStats();
        };
        showLevelUpModal = (nextLevel) => {
            isPaused = true;
            modals.levelUp.querySelector('#levelUpTitle').textContent = `¬°Nivel ${currentLevel} Completado!`;
            modals.levelUp.querySelector('#levelUpText').textContent = `¬°Felicidades! Prep√°rate para el nivel ${nextLevel}.`;
            modals.levelUp.style.display = 'flex';
        };
        goToNextLevel = () => { setupLevel(currentLevel + 1); placeNewTarget(); hideAndResume(); };
        showFeedback = (title, text) => {
            isPaused = true;
            modals.feedback.querySelector('#feedbackTitle').textContent = title;
            modals.feedback.querySelector('#feedbackText').textContent = text;
            modals.feedback.style.display = 'flex';
        };
        hideAndResume = () => {
            Object.values(modals).forEach(modal => modal.style.display = 'none');
            if (!gameOver) { isPaused = false; lastTime = performance.now(); }
        };
        handleInteractionStart = (e) => {
            if (isPaused) return;
            e.preventDefault();
            const coords = getInteractionCoords(e);
            panStart = { x: coords.x - panOffsetX, y: coords.y - panOffsetY };
            isPanning = true; hasPanned = false;
        };
        handleInteractionMove = (e) => {
            if (!isPanning || isPaused) return;
            e.preventDefault();
            const coords = getInteractionCoords(e);
            panOffsetX = coords.x - panStart.x;
            panOffsetY = coords.y - panStart.y;
            hasPanned = true;
            draw(); // Redraw on pan
        };
        handleInteractionEnd = (e) => {
            isPanning = false;
            if (hasPanned) return; // If it was a pan, don't treat it as a click
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const clickCoords = e.changedTouches ? {x: e.changedTouches[0].clientX - rect.left, y: e.changedTouches[0].clientY - rect.top} : {x: e.clientX - rect.left, y: e.clientY - rect.top};
            const dx = clickCoords.x - (target.x - panOffsetX);
            const dy = clickCoords.y - (target.y - panOffsetY);

            if (Math.sqrt(dx * dx + dy * dy) < target.radius) {
                const origin = { x: 50, y: canvas.height - 20 }; const pixelsPerMeter = 3;
                const realX = (target.x - origin.x) / pixelsPerMeter;
                const realY = (origin.y - target.y) / pixelsPerMeter;
                modals.targetInfo.querySelector('#targetCoordsText').innerHTML = `<strong>X:</strong> ${realX.toFixed(1)} m<br><strong>Y:</strong> ${realY.toFixed(1)} m`;
                modals.targetInfo.style.display = 'flex'; isPaused = true;
            }
        };

        // Event Listeners
        velocitySlider.addEventListener('input', e => { velocity = parseFloat(e.target.value); velocityValueSpan.textContent = velocity; });
        angleSlider.addEventListener('input', e => { angle = parseFloat(e.target.value); angleValueSpan.textContent = angle; });
        levelSelect.addEventListener('change', setupGame);
        fireButton.addEventListener('click', fireProjectile);
        pauseButton.addEventListener('click', () => { isPaused = !isPaused; pauseButton.textContent = isPaused ? "Reanudar" : "Pausa"; if(!isPaused) lastTime = performance.now(); });
        resetButton.addEventListener('click', setupGame);
        helpButton.addEventListener('click', () => { isPaused = true; modals.help.style.display = 'flex'; });
        modals.feedback.querySelector('#nextButton').addEventListener('click', hideAndResume);
        modals.targetInfo.querySelector('#closeTargetInfo').addEventListener('click', hideAndResume);
        modals.hint.querySelector('#closeHint').addEventListener('click', hideAndResume);
        modals.levelUp.querySelector('#nextLevelButton').addEventListener('click', goToNextLevel);
        modals.help.querySelector('#closeHelp').addEventListener('click', hideAndResume);
        
        // Panning listeners
        canvas.addEventListener('mousedown', handleInteractionStart);
        canvas.addEventListener('mousemove', handleInteractionMove);
        canvas.addEventListener('mouseup', handleInteractionEnd);
        canvas.addEventListener('mouseleave', () => isPanning = false);
        canvas.addEventListener('touchstart', handleInteractionStart, { passive: false });
        canvas.addEventListener('touchmove', handleInteractionMove, { passive: false });
        canvas.addEventListener('touchend', handleInteractionEnd);
        
        window.addEventListener('resize', setupGame);
        setupGame();
    </script>
</body>
</html>
